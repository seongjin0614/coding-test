import sys
# input.txt 파일은 현재 파이썬 파일과 같은 경로에 위치
sys.stdin = open("input.txt","r")
# ------------------------------------------------------------------------------------------------------------------------------------------------   
# <문제>
# : 1012 _ 유기농 배추
# https://www.acmicpc.net/problem/1012
# <등급>
# : 실버 2
    
# <내가 파악한 요구사항>
# : 그래프 탐색

# <실제 요구사항>
# : 그래프 탐색, 그래프 이론
#   너비 우선 탐색, 깊이 우선 탐색
# ------------------------------------------------------------------------------------------------------------------------------------------------   
# <수도코드>
'''
입,출력
테스트케이스를 입력 받고 함수를 호출해 결과값을 출력

필요한 배추흰지렁이의 마리 수를 구하는 함수
그래프를 탐색하면서 상,하,좌,우의값이 1인지 확인




'''
# ------------------------------------------------------------------------------------------------------------------------------------------------   
# <문제풀이>

def count_earthworm():
    m,n,k = map(int, input().split())
    
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    
    farm = [[0]*m]*n
    
    for _ in range(k):
        y, x = map(int, input().split())
        farm[y][x] = 1
    
    count = 0
    
    for i in range(m):
        for j in range(n):
            

    return count

t = int(input())
for _ in range(t):
    print(count_earthworm())
# ------------------------------------------------------------------------------------------------------------------------------------------------   
# <정답 및 다른풀이>
from collections import deque

def count_earthworm():
    m, n, k = map(int, input().split())  # 가로(m), 세로(n), 배추 개수(k)
    
    dx = [-1, 1, 0, 0]  # 상, 하, 좌, 우 이동
    dy = [0, 0, -1, 1]
    
    # 배추밭 초기화
    farm = [[0] * m for _ in range(n)]
    
    # 배추 심기
    for _ in range(k):
        x, y = map(int, input().split())
        farm[y][x] = 1
    
    def bfs(x, y):
        queue = deque([(x, y)])
        farm[y][x] = 0  # 방문 처리
        
        while queue:
            cur_x, cur_y = queue.popleft()
            
            for i in range(4):  # 4방향 탐색
                nx, ny = cur_x + dx[i], cur_y + dy[i]
                
                if 0 <= nx < m and 0 <= ny < n and farm[ny][nx] == 1:
                    farm[ny][nx] = 0  # 방문 처리
                    queue.append((nx, ny))
    
    count = 0
    
    for y in range(n):  # 세로 탐색
        for x in range(m):  # 가로 탐색
            if farm[y][x] == 1:  # 배추가 심어진 곳 발견
                bfs(x, y)  # 해당 배추 군집 탐색
                count += 1  # 지렁이 추가
    
    return count


# 테스트 케이스 처리
t = int(input())  # 테스트 케이스 수
for _ in range(t):
    print(count_earthworm())
# ------------------------------------------------------------------------------------------------------------------------------------------------   
# <문제를 통한 학습 내용>
'''
차이점
1. farm = [[0]*m for _ in range(n)]
	• 리스트 컴프리헨션을 사용해 각 행이 독립적인 리스트로 만들어집니다.
	• 즉, farm의 각 행은 서로 다른 리스트 객체를 참조합니다.
	• 이 방식은 의도한 대로 작동합니다.

2. farm2 = [[0]*m]*n
	• 이 방식은 [0]*m으로 만든 같은 리스트를 n번 반복하여 참조합니다.
	• 즉, farm2의 모든 행이 같은 리스트 객체를 참조합니다.
	• 하나의 행을 수정하면, 다른 모든 행도 같이 수정됩니다.
	• 따라서 의도한 대로 작동하지 않을 가능성이 높습니다.
'''